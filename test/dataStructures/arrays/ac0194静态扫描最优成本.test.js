/**
 * 题目0194-静态代码扫描服务
 * https://wiki.amoscloud.com/zh/ProgramingPractice/NowCoder/Adecco/Topic0194
 * 
 * 相关标签 数组 动态规划
 * 
 * 题目描述
 * 静态扫描快速识别源代码的缺陷，静态扫描的结果以扫描报告作为输出：
 * 1. 文件扫描的成本和文件大小相关，如果文件大小为 n，则扫描成本为 n 个金币
 * 2. 扫描报告的缓存成本和文件大小无关，每缓存一个报告需要 m 个金币
 * 3. 扫描报告缓存后，后续再碰到该文件则不需要扫描成本，直接获取缓存结果
 * 给出源代码文件标识序列和文件大小序列，求解采用合理的缓存策略，最少需要的金币数。
 * 说明: 需要判断是否需要缓存，计算最少需求金币数
 * 
 * 输入描述
 * 第一行为缓存一个报告金币数 m ,1 ≤ m ≤ 100
 * 第二行为文件标识序列：F1,F2,F3...Fn，其中1 ≤ n ≤ 10000，1≤ F ≤ 1000中
 * 第三行为文件大小序列：S1,S2,S3...Sn，其中1 ≤ n ≤ 10000，1≤ F ≤ 10
 * 
 * 输出描述
 * 采用合理的缓存策略，需要的最少金币数
 * */ 

// 示例一
// 输入
// 5 -> 缓存成本
// 1 2 2 1 2 3 4 - > 原文件标识序列
// 1 1 1 1 1 1 1 -> 文件大小
// 输出
// 7
// 说明
// 文件大小相同，扫描成本均为1个金币。缓存任意文件均不合算，因而最少成本为7金币

// 示例二
// 入参输入
// 5
// 2 2 2 2 2 5 2 2 2
// 3 3 3 3 3 1 3 3 3
// 出参输出
// 9
// 说明
// 2号文件出现了8次，扫描加缓存成本共计3+5=8，不缓存成本为3*8=24，显然缓存更优，最优成本为8+1=9。


const minCost = require('../../../src/dataStructures/arrays/ac0194静态扫描最优成本');

describe('删除有序数组中的重复项', function () {
    test('示例一', () => {
        let m = 5, fileIds = '1 2 2 1 2 3 4', fileSizes = '1 1 1 1 1 1 1'
        expect(minCost(m, fileIds,fileSizes)).toBe(7);
    });

    test('示例二', () => {
        let m = 5, fileIds = '2 2 2 2 2 5 2 2 2', fileSizes = '3 3 3 3 3 1 3 3 3'
        expect(minCost(m, fileIds,fileSizes)).toBe(9);
    });
});